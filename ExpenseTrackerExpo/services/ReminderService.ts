import AsyncStorage from '@react-native-async-storage/async-storage';
import { Reminder } from '../types/PaymentTypes';

import { API_BASE_URL } from '../config/api.config';
import { authenticatedFetch } from './authenticatedRequest';

// Get user ID for local storage keys
const getUserId = async () => {
  try {
    const userData = await AsyncStorage.getItem('user');
    if (userData) {
      const user = JSON.parse(userData);
      return user.email || user.id || 'default';
    }
    return 'default';
  } catch (error) {
    console.log('ğŸ” ReminderService: Error getting user ID:', error);
    return 'default';
  }
};

// Local storage helpers
const getLocalStorageKey = async (suffix: string) => {
  const userId = await getUserId();
  return `reminders_${suffix}_${userId}`;
};

export default {
  /**
   * Get all reminders from backend API only (cloud-first approach)
   */
  async getReminders(): Promise<Reminder[]> {
    try {
      console.log('ğŸ” ReminderService: Fetching reminders from backend API...');
      
      const response = await authenticatedFetch(`${API_BASE_URL}/reminders`, {
        method: 'GET',
      });

      console.log('ğŸ” ReminderService: Response status:', response.status);

      if (!response.ok) {
        console.error('ğŸ” ReminderService: HTTP error! status:', response.status);
        // If still 401 after refresh, throw error to be caught by caller
        if (response.status === 401) {
          throw new Error('Authentication failed. Please login again.');
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      console.log('ğŸ” ReminderService: API response:', result);
      
      if (result.success) {
        console.log('ğŸ” ReminderService: Successfully fetched reminders:', result.data.length);
        
        // Convert backend format to mobile app format
        const reminders = result.data.map((backendReminder: any) => ({
          id: backendReminder.id,
          title: backendReminder.title,
          description: backendReminder.description,
          type: backendReminder.type,
          date: new Date(backendReminder.due_date),
          dueDate: new Date(backendReminder.due_date),
          time: backendReminder.reminder_time ? backendReminder.reminder_time.split(':').slice(0, 2).join(':') : '09:00', // Convert HH:MM:SS to HH:MM
          isEnabled: backendReminder.is_enabled !== undefined ? backendReminder.is_enabled : true,
          repeat: backendReminder.repeat_type || 'none',
          category: backendReminder.category,
          amount: backendReminder.amount,
          isAutoGenerated: backendReminder.is_auto_generated || false,
          sourceType: backendReminder.source_type || 'manual',
          sourceId: backendReminder.source_id,
          paidAt: backendReminder.paid_at ? new Date(backendReminder.paid_at) : undefined,
          createdAt: new Date(backendReminder.created_at),
          updatedAt: new Date(backendReminder.updated_at)
        }));

        // Update local cache for offline reference (read-only)
        const storageKey = await getLocalStorageKey('all');
        await AsyncStorage.setItem(storageKey, JSON.stringify(reminders));
        
        return reminders;
      } else {
        console.error('ğŸ” ReminderService: API returned error:', result.message);
        throw new Error(result.message || 'Failed to fetch reminders');
      }
    } catch (error) {
      console.error('ğŸ” ReminderService: Error fetching reminders from API:', error);
      console.log('ğŸ” ReminderService: No fallback - cloud storage is the single source of truth');
      
      // Return empty array if cloud is unavailable
      return [];
    }
  },

  /**
   * Create a new reminder via API only -- (cloud-first approach)
   */
  async createReminder(reminder: Omit<Reminder, 'id' | 'createdAt' | 'updatedAt'>): Promise<{ success: boolean; id?: string }> {
    try {
      console.log('ğŸ” ReminderService: Creating reminder via API...');
      console.log('ğŸ” ReminderService: Original dueDate:', reminder.dueDate, typeof reminder.dueDate);
      
      // Ensure dueDate is properly converted to Date object
      const dueDate = new Date(reminder.dueDate);
      if (isNaN(dueDate.getTime())) {
        console.error('ğŸ” ReminderService: Invalid dueDate:', reminder.dueDate);
        throw new Error('Invalid dueDate provided');
      }
      
      // Convert mobile app format to backend format
      const reminderSourceType = (reminder as any).sourceType;
      const reminderSourceId = (reminder as any).sourceId;
      
      const backendReminder = {
        title: reminder.title,
        description: reminder.description,
        type: reminder.type,
        dueDate: dueDate.toISOString(), // Ensure proper Date object conversion
        reminderTime: reminder.time.split(':').slice(0, 2).join(':'), // Convert HH:MM:SS:MS to HH:MM (keep only hours and minutes)
        isEnabled: reminder.isEnabled,
        repeatType: reminder.repeat,
        category: reminder.category,
        amount: reminder.amount,
        isAutoGenerated: reminder.isAutoGenerated || false,
        sourceType: reminderSourceType || 'manual', // Default to 'manual' if null/undefined
        sourceId: reminderSourceId || undefined // Remove null values
      };
      
      console.log('ğŸ” ReminderService: Converted dueDate:', backendReminder.dueDate);
      console.log('ğŸ” ReminderService: Converted reminderTime:', backendReminder.reminderTime);
      console.log('ğŸ” ReminderService: SourceType:', backendReminder.sourceType);
      console.log('ğŸ” ReminderService: SourceId:', backendReminder.sourceId);

      const response = await authenticatedFetch(`${API_BASE_URL}/reminders`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(backendReminder),
      });

      console.log('ğŸ” ReminderService: Create reminder response status:', response.status);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('ğŸ” ReminderService: HTTP error! status:', response.status);
        console.error('ğŸ” ReminderService: Error response:', errorText);
        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
      }

      const result = await response.json();
      console.log('ğŸ” ReminderService: Successfully created reminder:', result.data?.id);
      
      if (result.success) {
        return { success: true, id: result.data.id };
      } else {
        console.error('ğŸ” ReminderService: API returned error:', result.message);
        throw new Error(result.message || 'Failed to create reminder');
      }
    } catch (error) {
      console.error('ğŸ” ReminderService: Error creating reminder via API:', error);
      console.log('ğŸ” ReminderService: No fallback - cloud storage is required');
      
      // No fallback - cloud storage is the single source of truth
      throw error;
    }
  },

  /**
   * Update a reminder via API only (cloud-first approach)
   */
  async updateReminder(id: string, updates: Partial<Reminder>): Promise<{ success: boolean }> {
    try {
      console.log('ğŸ” ReminderService: Updating reminder via API...');
      
      // Convert mobile app format to backend format
      const backendUpdates: any = {};
      if (updates.title !== undefined) backendUpdates.title = updates.title;
      if (updates.description !== undefined) backendUpdates.description = updates.description;
      if (updates.type !== undefined) backendUpdates.type = updates.type;
      if (updates.dueDate !== undefined) backendUpdates.dueDate = new Date(updates.dueDate).toISOString();
      if (updates.time !== undefined) backendUpdates.reminderTime = updates.time.split(':').slice(0, 2).join(':'); // Convert HH:MM:SS:MS to HH:MM (keep only hours and minutes)
      if (updates.isEnabled !== undefined) backendUpdates.isEnabled = updates.isEnabled;
      if (updates.repeat !== undefined) backendUpdates.repeatType = updates.repeat;
      if (updates.category !== undefined) backendUpdates.category = updates.category;
      if (updates.amount !== undefined) backendUpdates.amount = updates.amount;
      if ((updates as any).sourceType !== undefined) backendUpdates.sourceType = (updates as any).sourceType || 'manual';
      if ((updates as any).sourceId !== undefined) backendUpdates.sourceId = (updates as any).sourceId || undefined;
      if ((updates as any).paidAt !== undefined) backendUpdates.paidAt = (updates as any).paidAt ? new Date((updates as any).paidAt).toISOString() : null;

      const response = await authenticatedFetch(`${API_BASE_URL}/reminders/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(backendUpdates),
      });

      console.log('ğŸ” ReminderService: Update reminder response status:', response.status);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('ğŸ” ReminderService: HTTP error! status:', response.status);
        console.error('ğŸ” ReminderService: Error response:', errorText);
        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
      }

      const result = await response.json();
      console.log('ğŸ” ReminderService: Successfully updated reminder');
      
      if (result.success) {
        return { success: true };
      } else {
        console.error('ğŸ” ReminderService: API returned error:', result.message);
        throw new Error(result.message || 'Failed to update reminder');
      }
    } catch (error) {
      console.error('ğŸ” ReminderService: Error updating reminder via API:', error);
      console.log('ğŸ” ReminderService: No fallback - cloud storage is required');
      
      // No fallback - cloud storage is the single source of truth
      throw error;
    }
  },

  /**
   * Delete a reminder via API only (cloud-first approach)
   */
  async deleteReminder(id: string): Promise<{ success: boolean }> {
    try {
      console.log('ğŸ” ReminderService: Deleting reminder via API...');
      
      const response = await authenticatedFetch(`${API_BASE_URL}/reminders/${id}`, {
        method: 'DELETE',
      });

      console.log('ğŸ” ReminderService: Delete reminder response status:', response.status);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('ğŸ” ReminderService: HTTP error! status:', response.status);
        console.error('ğŸ” ReminderService: Error response:', errorText);
        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
      }

      const result = await response.json();
      console.log('ğŸ” ReminderService: Successfully deleted reminder');
      
      if (result.success) {
        return { success: true };
      } else {
        console.error('ğŸ” ReminderService: API returned error:', result.message);
        throw new Error(result.message || 'Failed to delete reminder');
      }
    } catch (error) {
      console.error('ğŸ” ReminderService: Error deleting reminder via API:', error);
      console.log('ğŸ” ReminderService: No fallback - cloud storage is required');
      
      // No fallback - cloud storage is the single source of truth
      throw error;
    }
  },

  /**
   * Get reminder statistics
   */
  async getReminderStats(): Promise<any> {
    try {
      console.log('ğŸ” ReminderService: Fetching reminder stats from API...');
      
      const response = await authenticatedFetch(`${API_BASE_URL}/reminders/stats`, {
        method: 'GET',
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      
      if (result.success) {
        console.log('ğŸ” ReminderService: Successfully fetched reminder stats');
        return result.data;
      } else {
        throw new Error(result.message || 'Failed to fetch reminder stats');
      }
    } catch (error) {
      console.error('ğŸ” ReminderService: Error fetching reminder stats:', error);
      
      // Fallback to local calculation
      const reminders = await this.getReminders();
      return {
        total: reminders.length,
        active: reminders.filter(r => r.isEnabled).length,
        autoGenerated: reminders.filter(r => r.isAutoGenerated).length,
        upcoming: reminders.filter(r => r.dueDate > new Date()).length,
        overdue: reminders.filter(r => r.dueDate < new Date() && r.repeat === 'none').length,
        byType: reminders.reduce((acc, r) => {
          acc[r.type] = (acc[r.type] || 0) + 1;
          return acc;
        }, {} as Record<string, number>)
      };
    }
  },


};
